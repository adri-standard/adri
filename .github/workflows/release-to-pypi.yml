name: Release to PyPI (TestPyPI ‚Üí Production)

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      tag_name:
        description: 'Tag to release (e.g., Release.Minor.v0.3.0)'
        required: true
        type: string
      force_republish:
        description: 'Force republish even if version exists'
        required: false
        type: boolean
        default: false

env:
  PYTHON_VERSION: "3.11"

jobs:
  validate-version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.validate.outputs.version }}
      tag_name: ${{ steps.validate.outputs.tag_name }}
      is_prerelease: ${{ steps.validate.outputs.is_prerelease }}
      release_type: ${{ steps.validate.outputs.release_type }}
      validation_result: ${{ steps.validate.outputs.validation_result }}
    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Validate release tag and version
      id: validate
      run: |
        # Get the tag name from event or input
        if [ "${{ github.event_name }}" = "release" ]; then
          TAG_NAME="${{ github.event.release.tag_name }}"
        else
          TAG_NAME="${{ github.event.inputs.tag_name }}"
        fi

        echo "üîç Processing release tag: $TAG_NAME"

        # Handle candidate tags (from draft releases)
        if [[ "$TAG_NAME" == candidate-* ]]; then
          echo "üìã Converting candidate tag to proper release tag..."

          # Extract type and version from candidate tag
          # candidate-minor-v0.3.0 -> Release.Minor.v0.3.0
          # candidate-beta-minor-v0.3.0 -> Pre-release.Minor.v0.3.0-beta.1

          if [[ "$TAG_NAME" == candidate-beta-* ]]; then
            # Beta release: candidate-beta-minor-v0.3.0 -> Pre-release.Minor.v0.3.0-beta.1
            CHANGE_TYPE=$(echo "$TAG_NAME" | sed 's/candidate-beta-\([^-]*\)-v.*/\1/')
            VERSION_BASE=$(echo "$TAG_NAME" | sed 's/candidate-beta-[^-]*-v\(.*\)/\1/')
            PROPER_TAG="Pre-release.${CHANGE_TYPE^}.v${VERSION_BASE}-beta.1"
          else
            # Production release: candidate-minor-v0.3.0 -> Release.Minor.v0.3.0
            CHANGE_TYPE=$(echo "$TAG_NAME" | sed 's/candidate-\([^-]*\)-v.*/\1/')
            VERSION_BASE=$(echo "$TAG_NAME" | sed 's/candidate-[^-]*-v\(.*\)/\1/')
            PROPER_TAG="Release.${CHANGE_TYPE^}.v${VERSION_BASE}"
          fi

          echo "üîÑ Converted: $TAG_NAME -> $PROPER_TAG"
          TAG_NAME="$PROPER_TAG"
        fi

        echo "üîç Validating release tag: $TAG_NAME"

        # Run version validation script and capture outputs
        cd scripts
        VALIDATION_OUTPUT=$(python validate_version.py "$TAG_NAME" 2>&1)
        VALIDATION_EXIT_CODE=$?

        # Check if validation failed
        if [ $VALIDATION_EXIT_CODE -ne 0 ]; then
          echo "‚ùå Version validation failed!"
          echo "$VALIDATION_OUTPUT"
          exit $VALIDATION_EXIT_CODE
        fi

        # Extract outputs from validation script
        VERSION=$(echo "$VALIDATION_OUTPUT" | grep "^version=" | cut -d'=' -f2)
        IS_PRERELEASE=$(echo "$VALIDATION_OUTPUT" | grep "^is_prerelease=" | cut -d'=' -f2)
        RELEASE_TYPE=$(echo "$VALIDATION_OUTPUT" | grep "^release_type=" | cut -d'=' -f2)

        # Set GitHub Actions outputs
        echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
        echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT

        echo "‚úÖ Version validation successful!"
        echo "üè∑Ô∏è Tag: $TAG_NAME"
        echo "üì¶ Version: $VERSION"
        echo "üß™ Pre-release: $IS_PRERELEASE"
        echo "üîÑ Release Type: $RELEASE_TYPE"

  test:
    needs: validate-version
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e ".[dev]"

    - name: Update version in files
      run: |
        VERSION="${{ needs.validate-version.outputs.version }}"
        echo "Updating version to: $VERSION"

        # Update pyproject.toml
        sed -i "s/^version = .*/version = \"$VERSION\"/" pyproject.toml

        # Update adri/version.py
        sed -i "s/__version__ = .*/__version__ = \"$VERSION\"/" adri/version.py

        # Verify updates
        echo "pyproject.toml version:"
        grep "^version = " pyproject.toml
        echo "adri/version.py version:"
        grep "__version__ = " adri/version.py

    - name: Run full test suite
      run: |
        pytest tests/ -v --cov=adri --cov-report=xml --cov-fail-under=90
      env:
        ADRI_VERSION: ${{ needs.validate-version.outputs.version }}

    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results
        path: |
          coverage.xml
          htmlcov/

  build:
    needs: [validate-version, test]
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Update version in files
      run: |
        VERSION="${{ needs.validate-version.outputs.version }}"
        sed -i "s/^version = .*/version = \"$VERSION\"/" pyproject.toml
        sed -i "s/__version__ = .*/__version__ = \"$VERSION\"/" adri/version.py

    - name: Install build dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build twine

    - name: Build package
      run: |
        python -m build

    - name: Check package
      run: |
        twine check dist/*
        echo "üì¶ Built packages:"
        ls -la dist/

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: dist-${{ needs.validate-version.outputs.version }}
        path: dist/

  publish-testpypi:
    needs: [validate-version, build]
    runs-on: ubuntu-latest
    environment: testpypi
    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: dist-${{ needs.validate-version.outputs.version }}
        path: dist/

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install twine
      run: |
        python -m pip install --upgrade pip
        pip install twine

    - name: Publish to TestPyPI
      run: |
        echo "üß™ Publishing to TestPyPI..."
        twine upload --repository testpypi dist/* --verbose
      env:
        TWINE_USERNAME: __token__
        TWINE_PASSWORD: ${{ secrets.TESTPYPI }}

    - name: Notify TestPyPI Success
      run: |
        echo "‚úÖ Successfully published to TestPyPI"
        echo "üì¶ Package: https://test.pypi.org/project/adri/${{ needs.validate-version.outputs.version }}/"

  smoke-test-testpypi:
    needs: [validate-version, publish-testpypi]
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: TestPyPI Smoke Tests
      run: |
        echo "üß™ Running TestPyPI smoke tests..."
        VERSION="${{ needs.validate-version.outputs.version }}"

        # Wait for TestPyPI propagation
        echo "‚è≥ Waiting for TestPyPI propagation..."
        sleep 60

        # Create clean test environment
        cd /tmp
        python -m venv testpypi_env
        source testpypi_env/bin/activate

        # Install from TestPyPI
        echo "üì¶ Installing from TestPyPI..."
        pip install -i https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ adri==$VERSION

        # Run comprehensive tests
        echo "‚úÖ Running comprehensive tests..."
        python -c "
        import time
        import pandas as pd
        from adri import adri_protected
        import adri

        # Version check
        print(f'‚úÖ Version: {adri.__version__}')
        assert adri.__version__ == '$VERSION', f'Version mismatch: {adri.__version__} != $VERSION'

        # Basic functionality check
        @adri_protected()
        def test_function(data):
            return data.shape[0]

        df = pd.DataFrame({'test': range(100)})
        start = time.time()
        result = test_function(df)
        duration = time.time() - start

        print(f'‚úÖ Functionality check: {duration:.2f}s')
        assert duration < 10.0, f'Performance regression: {duration}s'
        assert result == 100, f'Result mismatch: {result} != 100'

        print('üéâ All TestPyPI smoke tests passed!')
        "

  publish-pypi:
    needs: [validate-version, smoke-test-testpypi]
    runs-on: ubuntu-latest
    environment: production
    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: dist-${{ needs.validate-version.outputs.version }}
        path: dist/

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install twine
      run: |
        python -m pip install --upgrade pip
        pip install twine

    - name: Check if version exists (unless forced)
      if: ${{ !github.event.inputs.force_republish }}
      run: |
        VERSION="${{ needs.validate-version.outputs.version }}"
        echo "üîç Checking if version $VERSION already exists on PyPI..."

        # Try to get package info
        if pip index versions adri | grep -q "$VERSION"; then
          echo "‚ùå Version $VERSION already exists on PyPI"
          echo "Use force_republish option to override (not recommended)"
          exit 1
        else
          echo "‚úÖ Version $VERSION is available for publishing"
        fi

    - name: Publish to Production PyPI
      run: |
        echo "üöÄ Publishing to Production PyPI..."
        twine upload dist/* --verbose
      env:
        TWINE_USERNAME: __token__
        TWINE_PASSWORD: ${{ secrets.PYPI }}

    - name: Notify Production Success
      run: |
        echo "‚úÖ Successfully published to Production PyPI"
        echo "üì¶ Package: https://pypi.org/project/adri/${{ needs.validate-version.outputs.version }}/"

  smoke-test-pypi:
    needs: [validate-version, publish-pypi]
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Production PyPI Smoke Tests
      run: |
        echo "üß™ Running Production PyPI smoke tests..."
        VERSION="${{ needs.validate-version.outputs.version }}"

        # Wait for PyPI propagation
        echo "‚è≥ Waiting for PyPI propagation..."
        sleep 60

        # Create clean test environment
        cd /tmp
        python -m venv production_env
        source production_env/bin/activate

        # Install from production PyPI
        echo "üì¶ Installing from Production PyPI..."
        pip install adri==$VERSION

        # Run comprehensive tests
        echo "‚úÖ Running comprehensive tests..."
        python -c "
        import time
        import pandas as pd
        from adri import adri_protected
        import adri

        # Version check
        print(f'‚úÖ Version: {adri.__version__}')
        assert adri.__version__ == '$VERSION', f'Version mismatch: {adri.__version__} != $VERSION'

        # Basic functionality check
        @adri_protected()
        def test_function(data):
            return data.shape[0]

        df = pd.DataFrame({'test': range(100)})
        start = time.time()
        result = test_function(df)
        duration = time.time() - start

        print(f'‚úÖ Functionality check: {duration:.2f}s')
        assert duration < 10.0, f'Performance regression: {duration}s'
        assert result == 100, f'Result mismatch: {result} != 100'

        print('üéâ All production smoke tests passed!')
        "

  finalize-release:
    needs: [validate-version, smoke-test-pypi]
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Update release with success status
      if: github.event_name == 'release'
      run: |
        VERSION="${{ needs.validate-version.outputs.version }}"
        TAG_NAME="${{ needs.validate-version.outputs.tag_name }}"

        # Update release notes with deployment info
        gh release edit $TAG_NAME \
          --notes "üéâ **Release $TAG_NAME Successfully Deployed**

        ## ‚úÖ **Deployment Status**
        - ‚úÖ Tests passed on GitHub Actions
        - ‚úÖ Package validated on TestPyPI
        - ‚úÖ Package published to Production PyPI
        - ‚úÖ Smoke tests passed on both platforms

        ## üì¶ **Installation**
        \`\`\`bash
        pip install adri==$VERSION
        \`\`\`

        ## üîó **Links**
        - [PyPI Package](https://pypi.org/project/adri/$VERSION/)
        - [TestPyPI Package](https://test.pypi.org/project/adri/$VERSION/)
        - [Documentation](https://github.com/ThinkEvolveSolve/adri-validator/blob/main/README.md)
        - [Changelog](https://github.com/ThinkEvolveSolve/adri-validator/blob/main/CHANGELOG.md)

        ## üöÄ **Usage**
        \`\`\`python
        from adri import adri_protected

        @adri_protected()
        def your_ai_function(data):
            # Your AI/ML code here
            return processed_data
        \`\`\`"
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Slack Success Notification
      if: success()
      run: |
        VERSION="${{ needs.validate-version.outputs.version }}"
        TAG_NAME="${{ needs.validate-version.outputs.tag_name }}"

        echo "üéâ Release $TAG_NAME completed successfully!"
        echo "üì¶ Package available at: https://pypi.org/project/adri/$VERSION/"
        echo "üè∑Ô∏è GitHub release: https://github.com/ThinkEvolveSolve/adri-validator/releases/tag/$TAG_NAME"

        # TODO: Add Slack webhook notification here
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"üéâ ADRI Release '$TAG_NAME' deployed successfully!\nüì¶ https://pypi.org/project/adri/'$VERSION'/"}' \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}

  # Failure recovery job
  cleanup-on-failure:
    if: failure()
    needs: [validate-version, test, build, publish-testpypi, smoke-test-testpypi, publish-pypi, smoke-test-pypi, finalize-release]
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Determine failure stage
      id: failure-stage
      run: |
        if [[ "${{ needs.test.result }}" == "failure" ]]; then
          echo "stage=test" >> $GITHUB_OUTPUT
          echo "message=Test suite failed" >> $GITHUB_OUTPUT
        elif [[ "${{ needs.build.result }}" == "failure" ]]; then
          echo "stage=build" >> $GITHUB_OUTPUT
          echo "message=Package build failed" >> $GITHUB_OUTPUT
        elif [[ "${{ needs.publish-testpypi.result }}" == "failure" ]]; then
          echo "stage=testpypi" >> $GITHUB_OUTPUT
          echo "message=TestPyPI publication failed" >> $GITHUB_OUTPUT
        elif [[ "${{ needs.smoke-test-testpypi.result }}" == "failure" ]]; then
          echo "stage=testpypi-smoke" >> $GITHUB_OUTPUT
          echo "message=TestPyPI smoke tests failed" >> $GITHUB_OUTPUT
        elif [[ "${{ needs.publish-pypi.result }}" == "failure" ]]; then
          echo "stage=pypi" >> $GITHUB_OUTPUT
          echo "message=Production PyPI publication failed" >> $GITHUB_OUTPUT
        elif [[ "${{ needs.smoke-test-pypi.result }}" == "failure" ]]; then
          echo "stage=pypi-smoke" >> $GITHUB_OUTPUT
          echo "message=Production PyPI smoke tests failed" >> $GITHUB_OUTPUT
        else
          echo "stage=unknown" >> $GITHUB_OUTPUT
          echo "message=Unknown failure" >> $GITHUB_OUTPUT
        fi

    - name: Mark Release as Failed (if from release trigger)
      if: github.event_name == 'release'
      run: |
        TAG_NAME="${{ needs.validate-version.outputs.tag_name }}"
        FAILURE_STAGE="${{ steps.failure-stage.outputs.stage }}"
        FAILURE_MESSAGE="${{ steps.failure-stage.outputs.message }}"

        echo "üö® Marking release as failed..."

        # Convert release to draft and update with failure info
        gh release edit $TAG_NAME \
          --draft \
          --title "üö® FAILED: Release $TAG_NAME" \
          --notes "‚ùå **Release Failed During Deployment**

        ## üö® **Failure Details**
        - **Stage**: $FAILURE_STAGE
        - **Message**: $FAILURE_MESSAGE
        - **Workflow**: [${{ github.run_id }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
        - **Time**: $(date -u)

        ## üîß **To Retry**
        1. **Fix the issues** identified in the workflow logs
        2. **Push fixes** to the repository if needed
        3. **Re-publish this draft release** to trigger the workflow again
        4. **Same version number** - no need to bump

        ## üìã **Cleanup Status**
        - ‚úÖ Release marked as draft (can be re-published)
        - ‚úÖ Git tag preserved (no version bump needed)
        - ‚ö†Ô∏è PyPI packages cannot be automatically deleted if published

        ## üîó **Useful Links**
        - [Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
        - [Repository](https://github.com/${{ github.repository }})
        - [Issues](https://github.com/${{ github.repository }}/issues)"
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Slack Failure Notification
      run: |
        TAG_NAME="${{ needs.validate-version.outputs.tag_name }}"
        FAILURE_STAGE="${{ steps.failure-stage.outputs.stage }}"
        FAILURE_MESSAGE="${{ steps.failure-stage.outputs.message }}"

        echo "üö® Release $TAG_NAME failed at stage: $FAILURE_STAGE"
        echo "üí¨ Message: $FAILURE_MESSAGE"
        echo "üîó Workflow: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

        # TODO: Add Slack webhook notification here
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"üö® ADRI Release '$TAG_NAME' FAILED!\n‚ùå Stage: '$FAILURE_STAGE'\nüí¨ '$FAILURE_MESSAGE'\nüîó https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"}' \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}

    - name: Cleanup Summary
      run: |
        echo "üßπ Cleanup completed for failed release"
        echo "üìù Summary:"
        echo "   - Release marked as draft (can be re-published)"
        echo "   - Git tag preserved"
        echo "   - Team notified via Slack"
        echo "   - Workflow logs available for debugging"
